---
description: Детальное описание REST API для сервиса подсчёта калорий
globs: 
alwaysApply: false
---

# REST API Документация - Сервис подсчёта калорий

## Общая информация

**Базовый URL:** `/api/`

**Формат данных:** JSON

**Аутентификация:** JWT токены (Bearer Token)

**Кодировка:** UTF-8

---

## 1. Аутентификация и авторизация

### 1.1. Регистрация пользователя

**Эндпоинт:** `POST /api/auth/register/`

**Доступ:** Публичный (не требует аутентификации)

**Описание:** Создание нового аккаунта пользователя. После успешной регистрации пользователь автоматически получает JWT токены для доступа к защищённым эндпоинтам.

**Входные данные (Request Body):**

```json
{
  "first_name": "string (обязательно, 1-150 символов)",
  "email": "string (обязательно, валидный email, уникальный)",
  "password": "string (обязательно, минимум 8 символов)"
}
```

**Типы данных:**
- `first_name`: `string`, обязательное, длина: 1-150 символов
- `email`: `string`, обязательное, валидный email адрес, уникальный в системе
- `password`: `string`, обязательное, минимум 8 символов

**Выходные данные (Response 201 Created):**

```json
{
  "user": {
    "id": "integer",
    "email": "string",
    "first_name": "string"
  },
  "tokens": {
    "access": "string (JWT access token)",
    "refresh": "string (JWT refresh token)"
  }
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 400 | Email уже существует | `{"email": ["Пользователь с таким email уже существует."]}` |
| 400 | Имя невалидно (пустое, слишком длинное) | `{"first_name": ["Это поле обязательно.", "Убедитесь, что это значение содержит не более 150 символов."]}` |
| 400 | Пароль слишком короткий | `{"password": ["Пароль должен содержать минимум 8 символов."]}` |
| 400 | Email невалиден | `{"email": ["Введите правильный адрес электронной почты."]}` |

**Бизнес-логика:**
1. Проверка уникальности email в системе
2. Валидация формата email
3. Валидация длины имени (1-150 символов)
4. Валидация минимальной длины пароля (8 символов)
5. Создание пользователя в базе данных
6. Создание связанного профиля (Profile) с указанным именем
7. Генерация JWT токенов (access и refresh)
8. Возврат данных пользователя и токенов

---

### 1.2. Авторизация (Вход)

**Эндпоинт:** `POST /api/auth/login/`

**Доступ:** Публичный (не требует аутентификации)

**Описание:** Авторизация существующего пользователя по email и паролю. При успешной авторизации возвращаются JWT токены.

**Входные данные (Request Body):**

```json
{
  "email": "string (обязательно, валидный email)",
  "password": "string (обязательно)"
}
```

**Типы данных:**
- `email`: `string`, обязательное, валидный email адрес
- `password`: `string`, обязательное

**Выходные данные (Response 200 OK):**

```json
{
  "user": {
    "id": "integer",
    "email": "string",
    "first_name": "string"
  },
  "tokens": {
    "access": "string (JWT access token)",
    "refresh": "string (JWT refresh token)"
  }
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 401 | Неверный email или пароль | `{"detail": "Неверный email или пароль."}` |
| 400 | Email невалиден | `{"email": ["Введите правильный адрес электронной почты."]}` |
| 400 | Email или пароль слишком длинные | `{"email": ["Убедитесь, что это значение содержит не более 254 символов."]}` |

**Бизнес-логика:**
1. Валидация формата email
2. Проверка существования пользователя с указанным email
3. Проверка корректности пароля
4. Генерация JWT токенов (access и refresh)
5. Возврат данных пользователя и токенов
6. При неверных данных возвращается общая ошибка (без указания, что именно неверно - email или пароль) для безопасности

---

### 1.3. Обновление токена

**Эндпоинт:** `POST /api/auth/token/refresh/`

**Доступ:** Публичный (требует валидный refresh token)

**Описание:** Обновление access token с использованием refresh token.

**Входные данные (Request Body):**

```json
{
  "refresh": "string (обязательно, валидный refresh token)"
}
```

**Выходные данные (Response 200 OK):**

```json
{
  "access": "string (новый JWT access token)"
}
```

---

### 1.4. Выход (Logout)

**Эндпоинт:** `POST /api/auth/logout/`

**Доступ:** Требует аутентификации

**Описание:** Выход пользователя из системы. Refresh token добавляется в чёрный список.

**Входные данные (Request Body):**

```json
{
  "refresh": "string (обязательно, валидный refresh token)"
}
```

**Выходные данные (Response 200 OK):**

```json
{
  "detail": "Успешный выход из системы."
}
```

---

## 2. Профиль пользователя

### 2.1. Получение профиля

**Эндпоинт:** `GET /api/profile/`

**Доступ:** Требует аутентификации

**Описание:** Получение информации о текущем авторизованном пользователе (имя и email).

**Входные данные:** Нет (данные берутся из JWT токена)

**Выходные данные (Response 200 OK):**

```json
{
  "id": "integer",
  "email": "string",
  "first_name": "string"
}
```

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Возврат данных пользователя (email, имя из профиля)

---

### 2.2. Обновление имени и email

**Эндпоинт:** `PATCH /api/profile/` или `PUT /api/profile/`

**Доступ:** Требует аутентификации

**Описание:** Обновление имени и/или email текущего пользователя. Можно обновить одно или оба поля одновременно.

**Входные данные (Request Body):**

```json
{
  "first_name": "string (опционально, 1-150 символов)",
  "email": "string (опционально, валидный email, уникальный)"
}
```

**Типы данных:**
- `first_name`: `string`, опциональное, длина: 1-150 символов
- `email`: `string`, опциональное, валидный email адрес, уникальный в системе

**Выходные данные (Response 200 OK):**

```json
{
  "id": "integer",
  "email": "string",
  "first_name": "string"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 400 | Email уже существует | `{"email": ["Пользователь с таким email уже существует."]}` |
| 400 | Имя невалидно | `{"first_name": ["Убедитесь, что это значение содержит не более 150 символов."]}` |
| 400 | Email невалиден | `{"email": ["Введите правильный адрес электронной почты."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Валидация предоставленных полей
3. Проверка уникальности email (если изменяется)
4. Обновление полей пользователя и профиля
5. Возврат обновлённых данных

---

### 2.3. Смена пароля

**Эндпоинт:** `POST /api/profile/change-password/`

**Доступ:** Требует аутентификации

**Описание:** Изменение пароля текущего пользователя. Требуется указать старый пароль для подтверждения.

**Входные данные (Request Body):**

```json
{
  "old_password": "string (обязательно)",
  "new_password": "string (обязательно, минимум 8 символов)"
}
```

**Типы данных:**
- `old_password`: `string`, обязательное
- `new_password`: `string`, обязательное, минимум 8 символов

**Выходные данные (Response 200 OK):**

```json
{
  "detail": "Пароль успешно изменён."
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Старый пароль неверен | `{"old_password": ["Неверный пароль."]}` |
| 400 | Новый пароль слишком короткий | `{"new_password": ["Пароль должен содержать минимум 8 символов."]}` |
| 400 | Новый пароль совпадает со старым | `{"new_password": ["Новый пароль должен отличаться от старого."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Проверка корректности старого пароля
3. Валидация нового пароля (минимум 8 символов)
4. Проверка, что новый пароль отличается от старого
5. Обновление пароля пользователя
6. Возврат подтверждения успешного изменения

---

## 3. Главная страница (Управление блюдами и целями)

### 3.1. Получение данных за день

**Эндпоинт:** `GET /api/days/{date}/`

**Доступ:** Требует аутентификации

**Описание:** Получение всех данных за выбранный день: блюда, сгруппированные по приёмам пищи (Завтрак, Обед, Ужин, Перекус), и цели КБЖУ на день. Дата передаётся в формате YYYY-MM-DD.

**Параметры пути:**
- `date`: `string`, формат: `YYYY-MM-DD` (например, `2024-01-15`)

**Входные данные:** Нет

**Выходные данные (Response 200 OK):**

```json
{
  "date": "string (YYYY-MM-DD)",
  "goal": {
    "id": "integer",
    "calories": "integer (ккал)",
    "proteins": "decimal (г)",
    "fats": "decimal (г)",
    "carbohydrates": "decimal (г)",
    "is_auto_calculated": "boolean"
  } | null,
  "meals": {
    "breakfast": [
      {
        "id": "integer",
        "name": "string",
        "weight": "integer (г)",
        "calories": "integer (ккал)",
        "proteins": "decimal (г)",
        "fats": "decimal (г)",
        "carbohydrates": "decimal (г)",
        "meal_type": "string (breakfast)",
        "created_at": "string (ISO 8601)",
        "updated_at": "string (ISO 8601)"
      }
    ],
    "lunch": [...],
    "dinner": [...],
    "snack": [...]
  },
  "summary": {
    "total_calories": "integer (ккал)",
    "total_proteins": "decimal (г)",
    "total_fats": "decimal (г)",
    "total_carbohydrates": "decimal (г)",
    "goal_progress": {
      "calories_percent": "decimal (%)",
      "proteins_percent": "decimal (%)",
      "fats_percent": "decimal (%)",
      "carbohydrates_percent": "decimal (%)"
    }
  }
}
```

**Типы данных:**
- `date`: `string`, формат ISO 8601 (YYYY-MM-DD)
- `goal`: объект или `null` (если цель не установлена)
- `meals`: объект с ключами `breakfast`, `lunch`, `dinner`, `snack`, каждый содержит массив блюд
- `summary`: объект с суммарными значениями КБЖУ и процентами выполнения целей

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Неверный формат даты | `{"date": ["Неверный формат даты. Используйте YYYY-MM-DD."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Валидация формата даты
3. Получение цели КБЖУ на указанную дату (если существует)
4. Получение всех блюд пользователя за указанную дату
5. Группировка блюд по типам приёмов пищи (breakfast, lunch, dinner, snack)
6. Расчёт суммарных значений КБЖУ из всех блюд
7. Расчёт процентов выполнения целей (если цель установлена)
8. Возврат структурированных данных

---

### 3.2. Получение или создание цели на день

**Эндпоинт:** `GET /api/goals/{date}/` или `POST /api/goals/{date}/`

**Доступ:** Требует аутентификации

**Описание:** 
- `GET`: Получение цели КБЖУ на указанную дату
- `POST`: Создание или обновление цели КБЖУ на указанную дату

**Параметры пути:**
- `date`: `string`, формат: `YYYY-MM-DD`

**Входные данные для POST (Request Body):**

```json
{
  "calories": "integer (обязательно, минимум 1)",
  "proteins": "decimal (обязательно, минимум 0)",
  "fats": "decimal (обязательно, минимум 0)",
  "carbohydrates": "decimal (обязательно, минимум 0)"
}
```

**Типы данных:**
- `calories`: `integer`, обязательное, минимум 1
- `proteins`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой
- `fats`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой
- `carbohydrates`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой

**Выходные данные (Response 200 OK для GET, 201 Created для POST):**

```json
{
  "id": "integer",
  "date": "string (YYYY-MM-DD)",
  "calories": "integer (ккал)",
  "proteins": "decimal (г)",
  "fats": "decimal (г)",
  "carbohydrates": "decimal (г)",
  "is_auto_calculated": "boolean",
  "created_at": "string (ISO 8601)",
  "updated_at": "string (ISO 8601)"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 400 | Неверный формат даты | `{"date": ["Неверный формат даты."]}` |
| 400 | Калории должны быть больше 0 | `{"calories": ["Убедитесь, что это значение больше либо равно 1."]}` |
| 400 | Белки/жиры/углеводы не могут быть отрицательными | `{"proteins": ["Убедитесь, что это значение больше либо равно 0."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |
| 404 | Цель не найдена (только для GET) | `{"detail": "Цель на указанную дату не найдена."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Валидация формата даты
3. Для POST: валидация всех полей КБЖУ
4. Для POST: создание или обновление цели (upsert логика - если цель существует, обновляется)
5. Для GET: получение существующей цели или возврат 404
6. Возврат данных цели

---

### 3.3. Создание блюда

**Эндпоинт:** `POST /api/dishes/`

**Доступ:** Требует аутентификации

**Описание:** Создание нового блюда с указанием всех параметров КБЖУ. Блюдо должно быть привязано к конкретному приёму пищи и дате.

**Входные данные (Request Body):**

```json
{
  "name": "string (обязательно, максимум 255 символов)",
  "weight": "integer (обязательно, минимум 1, масса в граммах)",
  "calories": "integer (обязательно, минимум 0, калории в ккал)",
  "proteins": "decimal (обязательно, минимум 0, граммы)",
  "fats": "decimal (обязательно, минимум 0, граммы)",
  "carbohydrates": "decimal (обязательно, минимум 0, граммы)",
  "date": "string (обязательно, YYYY-MM-DD)",
  "meal_type": "string (обязательно, один из: breakfast, lunch, dinner, snack)"
}
```

**Типы данных:**
- `name`: `string`, обязательное, максимум 255 символов
- `weight`: `integer`, обязательное, минимум 1 (граммы)
- `calories`: `integer`, обязательное, минимум 0 (ккал)
- `proteins`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой (граммы)
- `fats`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой (граммы)
- `carbohydrates`: `decimal`, обязательное, минимум 0, максимум 2 знака после запятой (граммы)
- `date`: `string`, обязательное, формат YYYY-MM-DD
- `meal_type`: `string`, обязательное, один из: `breakfast`, `lunch`, `dinner`, `snack`

**Выходные данные (Response 201 Created):**

```json
{
  "id": "integer",
  "name": "string",
  "weight": "integer (г)",
  "calories": "integer (ккал)",
  "proteins": "decimal (г)",
  "fats": "decimal (г)",
  "carbohydrates": "decimal (г)",
  "meal_type": "string",
  "date": "string (YYYY-MM-DD)",
  "created_at": "string (ISO 8601)",
  "updated_at": "string (ISO 8601)"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 400 | Неверный тип приёма пищи | `{"meal_type": ["Выберите правильный вариант. Варианты: breakfast, lunch, dinner, snack."]}` |
| 400 | Неверный формат даты | `{"date": ["Неверный формат даты."]}` |
| 400 | Масса должна быть больше 0 | `{"weight": ["Убедитесь, что это значение больше либо равно 1."]}` |
| 400 | Калории не могут быть отрицательными | `{"calories": ["Убедитесь, что это значение больше либо равно 0."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Валидация всех полей
3. Валидация типа приёма пищи (должен быть один из допустимых значений)
4. Валидация формата даты
5. Поиск или создание приёма пищи (Meal) для указанной даты и типа
6. Создание блюда (Dish) с привязкой к пользователю и приёму пищи
7. Возврат созданного блюда

---

### 3.4. Получение блюда

**Эндпоинт:** `GET /api/dishes/{id}/`

**Доступ:** Требует аутентификации

**Описание:** Получение информации о конкретном блюде по его ID. Пользователь может получить только свои блюда.

**Параметры пути:**
- `id`: `integer`, ID блюда

**Выходные данные (Response 200 OK):**

```json
{
  "id": "integer",
  "name": "string",
  "weight": "integer (г)",
  "calories": "integer (ккал)",
  "proteins": "decimal (г)",
  "fats": "decimal (г)",
  "carbohydrates": "decimal (г)",
  "meal_type": "string",
  "date": "string (YYYY-MM-DD)",
  "created_at": "string (ISO 8601)",
  "updated_at": "string (ISO 8601)"
}
```

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |
| 404 | Блюдо не найдено или не принадлежит пользователю |

---

### 3.5. Обновление блюда

**Эндпоинт:** `PATCH /api/dishes/{id}/` или `PUT /api/dishes/{id}/`

**Доступ:** Требует аутентификации

**Описание:** Редактирование любого поля блюда. Пользователь может редактировать только свои блюда. Можно обновить одно или несколько полей одновременно.

**Параметры пути:**
- `id`: `integer`, ID блюда

**Входные данные (Request Body):**

```json
{
  "name": "string (опционально, максимум 255 символов)",
  "weight": "integer (опционально, минимум 1)",
  "calories": "integer (опционально, минимум 0)",
  "proteins": "decimal (опционально, минимум 0)",
  "fats": "decimal (опционально, минимум 0)",
  "carbohydrates": "decimal (опционально, минимум 0)",
  "meal_type": "string (опционально, один из: breakfast, lunch, dinner, snack)",
  "date": "string (опционально, YYYY-MM-DD)"
}
```

**Выходные данные (Response 200 OK):**

```json
{
  "id": "integer",
  "name": "string",
  "weight": "integer (г)",
  "calories": "integer (ккал)",
  "proteins": "decimal (г)",
  "fats": "decimal (г)",
  "carbohydrates": "decimal (г)",
  "meal_type": "string",
  "date": "string (YYYY-MM-DD)",
  "created_at": "string (ISO 8601)",
  "updated_at": "string (ISO 8601)"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |
| 403 | Блюдо не принадлежит пользователю | `{"detail": "У вас нет прав для выполнения этого действия."}` |
| 404 | Блюдо не найдено | `{"detail": "Блюдо не найдено."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Поиск блюда по ID
3. Проверка, что блюдо принадлежит текущему пользователю
4. Валидация обновляемых полей
5. Если изменяется `date` или `meal_type`, обновление связи с приёмом пищи (Meal)
6. Обновление полей блюда
7. Возврат обновлённого блюда

---

### 3.6. Удаление блюда

**Эндпоинт:** `DELETE /api/dishes/{id}/`

**Доступ:** Требует аутентификации

**Описание:** Удаление блюда. Пользователь может удалить только свои блюда.

**Параметры пути:**
- `id`: `integer`, ID блюда

**Выходные данные (Response 204 No Content):**

Тело ответа отсутствует

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |
| 403 | Блюдо не принадлежит пользователю |
| 404 | Блюдо не найдено |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Поиск блюда по ID
3. Проверка, что блюдо принадлежит текущему пользователю
4. Удаление блюда из базы данных
5. Возврат статуса 204

---

### 3.7. Распознавание блюда по фотографии

**Эндпоинт:** `POST /api/dishes/recognize/`

**Доступ:** Требует аутентификации

**Описание:** Отправка фотографии блюда в формате base64 для распознавания нейросетью. Сервер обращается к API распознавания изображений, определяет КБЖУ блюда и возвращает результат. Блюдо автоматически не создаётся - пользователь может просмотреть результат и при необходимости создать блюдо.

**Входные данные (Request Body):**

```json
{
  "image_base64": "string (обязательно, base64-encoded изображение)",
  "date": "string (опционально, YYYY-MM-DD, по умолчанию текущая дата)",
  "meal_type": "string (опционально, один из: breakfast, lunch, dinner, snack)"
}
```

**Типы данных:**
- `image_base64`: `string`, обязательное, изображение в формате base64 (с префиксом `data:image/jpeg;base64,` или без него)
- `date`: `string`, опциональное, формат YYYY-MM-DD (по умолчанию текущая дата)
- `meal_type`: `string`, опциональное, один из: `breakfast`, `lunch`, `dinner`, `snack`

**Выходные данные (Response 200 OK):**

```json
{
  "recognized_dishes": [
    {
      "name": "string (название блюда)",
      "weight": "integer (г, примерная масса)",
      "calories": "integer (ккал)",
      "proteins": "decimal (г)",
      "fats": "decimal (г)",
      "carbohydrates": "decimal (г)",
      "confidence": "decimal (0-1, уверенность распознавания)"
    }
  ],
  "suggested_date": "string (YYYY-MM-DD)",
  "suggested_meal_type": "string"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Ошибка валидации | `{"field_name": ["error message"]}` |
| 400 | Неверный формат изображения | `{"image_base64": ["Неверный формат изображения. Ожидается base64."]}` |
| 400 | Изображение слишком большое | `{"image_base64": ["Размер изображения не должен превышать 10 МБ."]}` |
| 400 | Неверный формат даты | `{"date": ["Неверный формат даты."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |
| 500 | Ошибка распознавания | `{"detail": "Не удалось распознать блюдо. Попробуйте ещё раз."}` |
| 503 | Сервис распознавания недоступен | `{"detail": "Сервис распознавания временно недоступен."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Валидация формата base64 изображения
3. Проверка размера изображения (максимум 10 МБ)
4. Декодирование base64 в бинарные данные
5. Отправка изображения в API распознавания (например, OpenAI Vision API или другой сервис)
6. Парсинг ответа от нейросети (название блюда, КБЖУ)
7. Валидация полученных данных
8. Возврат распознанных блюд с указанием уверенности распознавания
9. Если распознавание не удалось, возврат понятной ошибки

**Примечание:** После получения результата распознавания пользователь может использовать данные для создания блюда через эндпоинт `POST /api/dishes/`.

---

## 4. Управление подпиской

### 4.1. Получение информации о подписке

**Эндпоинт:** `GET /api/subscription/`

**Доступ:** Требует аутентификации

**Описание:** Получение информации о текущей активной подписке пользователя: название тарифа и остаток дней до окончания.

**Входные данные:** Нет

**Выходные данные (Response 200 OK):**

```json
{
  "plan_name": "string (название тарифа)",
  "status": "string (active, expired, cancelled)",
  "days_remaining": "integer (остаток дней, null если подписка истекла)",
  "end_date": "string (ISO 8601, дата окончания подписки)",
  "auto_renew": "boolean (автопродление включено/выключено)"
}
```

**Типы данных:**
- `plan_name`: `string`, название тарифного плана
- `status`: `string`, один из: `active`, `expired`, `cancelled`
- `days_remaining`: `integer` или `null`, количество дней до окончания подписки
- `end_date`: `string`, формат ISO 8601, дата окончания подписки
- `auto_renew`: `boolean`, включено ли автопродление

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Получение подписки пользователя (если не существует, создаётся подписка со статусом `expired`)
3. Расчёт остатка дней до окончания (если подписка активна)
4. Возврат информации о подписке

---

### 4.2. Оплата подписки (месячная)

**Эндпоинт:** `POST /api/subscription/pay-monthly/`

**Доступ:** Требует аутентификации

**Описание:** Создание платежа для оплаты месячной подписки. Инициирует процесс оплаты через платёжный провайдер (например, ЮKassa, Stripe). Возвращает ссылку на оплату или данные для редиректа.

**Входные данные (Request Body):**

```json
{
  "plan_id": "integer (опционально, ID тарифного плана, по умолчанию базовый план)"
}
```

**Типы данных:**
- `plan_id`: `integer`, опциональное, ID тарифного плана

**Выходные данные (Response 200 OK):**

```json
{
  "payment_id": "integer",
  "amount": "decimal (сумма в рублях)",
  "payment_url": "string (URL для редиректа на оплату)",
  "status": "string (pending)"
}
```

**Возможные ошибки:**

| Код | Описание | Тело ответа |
|-----|----------|-------------|
| 400 | Тарифный план не найден | `{"plan_id": ["Тарифный план не найден."]}` |
| 401 | Токен отсутствует или невалиден | `{"detail": "Учетные данные не были предоставлены."}` |
| 500 | Ошибка создания платежа | `{"detail": "Не удалось создать платёж. Попробуйте ещё раз."}` |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Получение тарифного плана (по ID или базовый)
3. Получение цены за месяц из тарифного плана
4. Создание записи платежа (Payment) со статусом `pending`
5. Инициализация платежа через платёжный провайдер
6. Получение URL для оплаты
7. Сохранение transaction_id от провайдера
8. Возврат данных платежа и URL для редиректа

---

### 4.3. Оплата подписки (годовая)

**Эндпоинт:** `POST /api/subscription/pay-yearly/`

**Доступ:** Требует аутентификации

**Описание:** Создание платежа для оплаты годовой подписки. Аналогично месячной подписке, но с годовой ценой.

**Входные данные (Request Body):**

```json
{
  "plan_id": "integer (опционально, ID тарифного плана, по умолчанию базовый план)"
}
```

**Выходные данные (Response 200 OK):**

```json
{
  "payment_id": "integer",
  "amount": "decimal (сумма в рублях)",
  "payment_url": "string (URL для редиректа на оплату)",
  "status": "string (pending)"
}
```

**Возможные ошибки:** Аналогично месячной подписке

**Бизнес-логика:** Аналогично месячной подписке, но используется `price_yearly` вместо `price_monthly`

---

### 4.4. Отключение автопродления

**Эндпоинт:** `POST /api/subscription/disable-auto-renew/`

**Доступ:** Требует аутентификации

**Описание:** Отключение автоматического продления подписки. После окончания текущей подписки она не будет автоматически продлена.

**Входные данные:** Нет

**Выходные данные (Response 200 OK):**

```json
{
  "detail": "Автопродление отключено.",
  "auto_renew": false
}
```

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Получение подписки пользователя
3. Установка `auto_renew = False`
4. Сохранение изменений
5. Возврат подтверждения

---

### 4.5. Включение автопродления

**Эндпоинт:** `POST /api/subscription/enable-auto-renew/`

**Доступ:** Требует аутентификации

**Описание:** Включение автоматического продления подписки.

**Входные данные:** Нет

**Выходные данные (Response 200 OK):**

```json
{
  "detail": "Автопродление включено.",
  "auto_renew": true
}
```

---

### 4.6. История платежей

**Эндпоинт:** `GET /api/subscription/payments/`

**Доступ:** Требует аутентификации

**Описание:** Получение истории всех платежей текущего пользователя. Платежи отсортированы по дате (новые первыми).

**Входные данные:** Нет

**Параметры запроса (Query Parameters):**
- `page`: `integer`, опциональное, номер страницы (для пагинации)
- `page_size`: `integer`, опциональное, количество элементов на странице (по умолчанию 20)

**Выходные данные (Response 200 OK):**

```json
{
  "count": "integer (общее количество платежей)",
  "next": "string | null (URL следующей страницы)",
  "previous": "string | null (URL предыдущей страницы)",
  "results": [
    {
      "id": "integer",
      "plan_name": "string (название тарифа)",
      "amount": "decimal (сумма в рублях)",
      "payment_type": "string (monthly, yearly)",
      "status": "string (pending, completed, failed, refunded)",
      "created_at": "string (ISO 8601, дата платежа)"
    }
  ]
}
```

**Типы данных:**
- `count`: `integer`, общее количество платежей
- `next`: `string` или `null`, URL следующей страницы (если есть)
- `previous`: `string` или `null`, URL предыдущей страницы (если есть)
- `results`: массив объектов платежей

**Возможные ошибки:**

| Код | Описание |
|-----|----------|
| 401 | Токен отсутствует или невалиден |

**Бизнес-логика:**
1. Извлечение пользователя из JWT токена
2. Получение всех платежей пользователя, отсортированных по дате создания (новые первыми)
3. Применение пагинации (если указаны параметры)
4. Формирование ответа с данными платежей
5. Возврат списка платежей с метаданными пагинации

---

## 5. Webhook для обработки платежей

### 5.1. Webhook от платёжного провайдера

**Эндпоинт:** `POST /api/subscription/webhook/`

**Доступ:** Публичный (защищён секретным ключом от провайдера)

**Описание:** Эндпоинт для получения уведомлений от платёжного провайдера о статусе платежа. Обновляет статус платежа и подписки в базе данных.

**Входные данные (Request Body):**

Зависит от платёжного провайдера. Обычно содержит:
- `transaction_id`: ID транзакции
- `status`: статус платежа
- `amount`: сумма платежа
- Другие данные от провайдера

**Выходные данные (Response 200 OK):**

```json
{
  "status": "ok"
}
```

**Бизнес-логика:**
1. Проверка подписи запроса (для безопасности)
2. Поиск платежа по transaction_id
3. Обновление статуса платежа
4. Если платеж успешен (`completed`):
   - Обновление подписки пользователя (установка статуса `active`)
   - Установка дат начала и окончания подписки (текущая дата + период подписки)
5. Возврат подтверждения

---

## Общие типы данных

### Форматы дат и времени

- **Дата:** `YYYY-MM-DD` (например, `2024-01-15`)
- **Дата и время:** ISO 8601 формат (например, `2024-01-15T10:30:00Z`)

### Типы полей

- **integer:** целое число
- **decimal:** десятичное число с фиксированной точностью (обычно 2 знака после запятой)
- **string:** строка текста
- **boolean:** логическое значение (`true` или `false`)
- **null:** отсутствующее значение

### Коды статусов HTTP

- **200 OK:** Успешный запрос
- **201 Created:** Ресурс успешно создан
- **204 No Content:** Успешный запрос без тела ответа (обычно для DELETE)
- **400 Bad Request:** Ошибка валидации или неверные данные
- **401 Unauthorized:** Требуется аутентификация или токен невалиден
- **403 Forbidden:** Доступ запрещён (пользователь не имеет прав)
- **404 Not Found:** Ресурс не найден
- **500 Internal Server Error:** Внутренняя ошибка сервера
- **503 Service Unavailable:** Сервис временно недоступен

---

## Аутентификация

Все защищённые эндпоинты требуют JWT токен в заголовке запроса:

```
Authorization: Bearer <access_token>
```

**Пример запроса:**

```http
GET /api/profile/ HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
Content-Type: application/json
```

---

## Обработка ошибок

Все ошибки возвращаются в формате JSON:

```json
{
  "detail": "Текст ошибки"
}
```

или для ошибок валидации:

```json
{
  "field_name": ["Сообщение об ошибке 1", "Сообщение об ошибке 2"]
}
```

---

## Пагинация

Для списков используется пагинация в формате:

```json
{
  "count": 100,
  "next": "http://api.example.com/api/resource/?page=2",
  "previous": null,
  "results": [...]
}
```

---

## Примечания

1. Все даты на сервере хранятся в UTC, но могут возвращаться в локальном времени пользователя (если реализовано)
2. Все денежные суммы указываются в рублях (RUB)
3. Масса блюд указывается в граммах
4. Калории указываются в килокалориях (ккал)
5. Белки, жиры, углеводы указываются в граммах
6. При создании блюда через распознавание изображения, пользователь должен самостоятельно вызвать эндпоинт создания блюда с полученными данными
