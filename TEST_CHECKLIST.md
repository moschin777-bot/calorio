# Чек-лист для тестирования REST API сервиса подсчёта калорий

## 1. Аутентификация и авторизация

### 1.1. Регистрация пользователя (POST /api/auth/register/)

1. Регистрация с корректными данными (first_name, email, password).
2. Регистрация с пустым полем first_name.
3. Регистрация с first_name длиннее 150 символов.
4. Регистрация с пустым email.
5. Регистрация с некорректным email (без символа @).
6. Регистрация с некорректным email (без точки после @).
7. Регистрация с email, который уже существует в системе.
8. Регистрация с пустым паролем.
9. Регистрация с паролем короче 8 символов.
10. Регистрация с паролем ровно 8 символов (граничное значение).
11. Регистрация с паролем длиннее 8 символов.
12. Проверка, что после успешной регистрации возвращаются токены (access и refresh).
13. Проверка, что после успешной регистрации возвращаются данные пользователя (id, email, first_name).
14. Проверка, что после регистрации создаётся профиль пользователя.

### 1.2. Авторизация (Вход) (POST /api/auth/login/)

15. Вход с корректными email и паролем.
16. Вход с пустым email.
17. Вход с пустым паролем.
18. Вход с несуществующим email.
19. Вход с неверным паролем для существующего пользователя.
20. Вход с некорректным email (без символа @).
21. Вход с некорректным email (без точки после @).
22. Вход с email длиннее 254 символов.
23. Вход с деактивированным аккаунтом (is_active=False).
24. Проверка, что после успешного входа возвращаются токены (access и refresh).
25. Проверка, что после успешного входа возвращаются данные пользователя (id, email, first_name).
26. Проверка, что при неверных данных возвращается общая ошибка (без указания, что именно неверно).

### 1.3. Обновление токена (POST /api/auth/token/refresh/)

27. Обновление access токена с валидным refresh токеном.
28. Обновление токена с пустым refresh токеном.
29. Обновление токена с невалидным refresh токеном.
30. Обновление токена с истёкшим refresh токеном.
31. Обновление токена с refresh токеном, который был добавлен в чёрный список (после logout).
32. Проверка, что после успешного обновления возвращается новый access токен.

### 1.4. Выход (Logout) (POST /api/auth/logout/)

33. Выход с валидным refresh токеном и авторизованным пользователем.
34. Выход с пустым refresh токеном.
35. Выход с невалидным refresh токеном.
36. Выход без токена авторизации (access token).
37. Выход с истёкшим access токеном.
38. Проверка, что после успешного выхода refresh токен добавляется в чёрный список.
39. Проверка, что после logout нельзя использовать тот же refresh токен для обновления access токена.

## 2. Профиль пользователя

### 2.1. Получение профиля (GET /api/profile/)

40. Получение профиля авторизованным пользователем.
41. Получение профиля без токена авторизации.
42. Получение профиля с невалидным токеном.
43. Получение профиля с истёкшим токеном.
44. Проверка, что возвращаются только поля: id, email, first_name.
45. Проверка корректности значений возвращаемых полей.

### 2.2. Обновление профиля (PATCH /api/profile/)

46. Обновление только first_name с корректным значением.
47. Обновление только email с корректным значением.
48. Обновление first_name и email одновременно.
49. Обновление first_name с пустым значением.
50. Обновление first_name длиннее 150 символов.
51. Обновление email с некорректным форматом.
52. Обновление email на уже существующий в системе (другой пользователь).
53. Обновление email на тот же email (без изменений).
54. Обновление профиля без токена авторизации.
55. Обновление профиля с невалидным токеном.
56. Проверка, что после успешного обновления возвращаются обновлённые данные.

### 2.3. Смена пароля (POST /api/profile/change-password/)

57. Смена пароля с корректными old_password и new_password.
58. Смена пароля с неверным old_password.
59. Смена пароля с пустым old_password.
60. Смена пароля с пустым new_password.
61. Смена пароля с new_password короче 8 символов.
62. Смена пароля с new_password равным old_password.
63. Смена пароля без токена авторизации.
64. Смена пароля с невалидным токеном.
65. Проверка, что после успешной смены пароля старый пароль не работает.
66. Проверка, что после успешной смены пароля новый пароль работает.

## 3. Управление блюдами

### 3.1. Создание блюда (POST /api/dishes/)

67. Создание блюда с обязательными полями (name, date, meal_type).
68. Создание блюда со всеми полями (name, date, meal_type, weight, calories, proteins, fats, carbohydrates).
69. Создание блюда без поля name.
70. Создание блюда с name длиннее 255 символов.
71. Создание блюда без поля date.
72. Создание блюда с некорректным форматом date (не YYYY-MM-DD).
73. Создание блюда с датой в будущем.
74. Создание блюда с датой в прошлом.
75. Создание блюда без поля meal_type.
76. Создание блюда с невалидным meal_type (не breakfast, lunch, dinner, snack).
77. Создание блюда с meal_type = breakfast.
78. Создание блюда с meal_type = lunch.
79. Создание блюда с meal_type = dinner.
80. Создание блюда с meal_type = snack.
81. Создание блюда без поля weight (должно установиться значение по умолчанию 1).
82. Создание блюда с weight = 0 (должна быть ошибка).
83. Создание блюда с weight < 0 (должна быть ошибка).
84. Создание блюда без поля calories (должно установиться значение по умолчанию 0).
85. Создание блюда с calories < 0 (должна быть ошибка).
86. Создание блюда без полей proteins, fats, carbohydrates (должны установиться значения по умолчанию 0).
87. Создание блюда с proteins < 0 (должна быть ошибка).
88. Создание блюда с fats < 0 (должна быть ошибка).
89. Создание блюда с carbohydrates < 0 (должна быть ошибка).
90. Создание блюда с proteins с более чем 2 знаками после запятой.
91. Создание блюда без токена авторизации.
92. Создание блюда с невалидным токеном.
93. Проверка, что после создания блюда создаётся или находится соответствующий Meal.
94. Проверка, что блюдо привязывается к текущему пользователю.

### 3.2. Получение списка блюд (GET /api/dishes/)

95. Получение списка блюд авторизованным пользователем.
96. Получение списка блюд без токена авторизации.
97. Получение списка блюд с фильтром по date (query параметр ?date=YYYY-MM-DD).
98. Получение списка блюд с некорректным форматом date в query параметре.
99. Получение списка блюд с фильтром по meal_type (query параметр ?meal_type=breakfast).
100. Получение списка блюд с невалидным meal_type в query параметре.
101. Получение списка блюд с поиском по названию (query параметр ?search=название).
102. Получение списка блюд с сортировкой по created_at (query параметр ?ordering=created_at).
103. Получение списка блюд с сортировкой по calories (query параметр ?ordering=calories).
104. Получение списка блюд с обратной сортировкой (query параметр ?ordering=-created_at).
105. Получение списка блюд с пагинацией (query параметр ?page=1).
106. Получение списка блюд с кастомным размером страницы (query параметр ?page_size=10).
107. Получение списка блюд с page_size больше максимального (max 100).
108. Проверка, что возвращаются только блюда текущего пользователя.
109. Проверка, что блюда других пользователей не отображаются.

### 3.3. Получение конкретного блюда (GET /api/dishes/{id}/)

110. Получение существующего блюда текущего пользователя.
111. Получение несуществующего блюда (404).
112. Получение блюда другого пользователя (403 или 404).
113. Получение блюда без токена авторизации.
114. Получение блюда с невалидным токеном.
115. Получение блюда с некорректным ID (не число).
116. Проверка, что возвращаются все поля блюда.

### 3.4. Обновление блюда (PATCH /api/dishes/{id}/)

117. Обновление только name блюда.
118. Обновление только weight блюда.
119. Обновление только calories блюда.
120. Обновление только proteins блюда.
121. Обновление только fats блюда.
122. Обновление только carbohydrates блюда.
123. Обновление нескольких полей одновременно.
124. Обновление date блюда (должен обновиться связанный Meal).
125. Обновление meal_type блюда (должен обновиться связанный Meal).
126. Обновление date и meal_type одновременно.
127. Обновление name на пустое значение.
128. Обновление name длиннее 255 символов.
129. Обновление weight на 0 (должна быть ошибка).
130. Обновление weight на отрицательное значение (должна быть ошибка).
131. Обновление calories на отрицательное значение (должна быть ошибка).
132. Обновление proteins на отрицательное значение (должна быть ошибка).
133. Обновление fats на отрицательное значение (должна быть ошибка).
134. Обновление carbohydrates на отрицательное значение (должна быть ошибка).
135. Обновление date с некорректным форматом.
136. Обновление meal_type на невалидное значение.
137. Обновление блюда другого пользователя (403).
138. Обновление несуществующего блюда (404).
139. Обновление блюда без токена авторизации.
140. Обновление блюда с невалидным токеном.
141. Проверка, что после обновления возвращаются обновлённые данные.

### 3.5. Удаление блюда (DELETE /api/dishes/{id}/)

142. Удаление существующего блюда текущего пользователя.
143. Удаление несуществующего блюда (404).
144. Удаление блюда другого пользователя (403).
145. Удаление блюда без токена авторизации.
146. Удаление блюда с невалидным токеном.
147. Удаление блюда с некорректным ID (не число).
148. Проверка, что после удаления блюдо действительно удаляется из базы.
149. Проверка, что после удаления блюда нельзя получить его по GET запросу.

### 3.6. Распознавание блюда по фотографии (POST /api/dishes/recognize/)

150. Распознавание блюда с корректным base64 изображением.
151. Распознавание блюда с указанием date.
152. Распознавание блюда с указанием meal_type.
153. Распознавание блюда с указанием date и meal_type.
154. Распознавание блюда без указания date (должна использоваться текущая дата).
155. Распознавание блюда с пустым image_base64.
156. Распознавание блюда с некорректным base64 (невалидные символы).
157. Распознавание блюда с изображением больше 10 МБ.
158. Распознавание блюда с некорректным форматом изображения (не изображение).
159. Распознавание блюда с некорректным форматом date.
160. Распознавание блюда с невалидным meal_type.
161. Распознавание блюда без токена авторизации.
162. Распознавание блюда с невалидным токеном.
163. Распознавание блюда при недоступном сервисе распознавания (503).
164. Распознавание блюда при ошибке API распознавания (500).
165. Проверка, что возвращаются поля: recognized_dishes, suggested_date, suggested_meal_type.
166. Проверка, что в recognized_dishes есть поля: name, weight, calories, proteins, fats, carbohydrates, confidence.
167. Проверка, что блюдо не создаётся автоматически после распознавания.
168. Проверка ограничения частоты запросов (throttling).

## 4. Управление целями КБЖУ

### 4.1. Получение цели на день (GET /api/goals/{date}/)

169. Получение существующей цели на указанную дату.
170. Получение цели на дату, для которой цель не установлена (404).
171. Получение цели с некорректным форматом date (не YYYY-MM-DD).
172. Получение цели без токена авторизации.
173. Получение цели с невалидным токеном.
174. Проверка, что возвращаются все поля цели: id, date, calories, proteins, fats, carbohydrates, is_auto_calculated, created_at, updated_at.
175. Проверка, что возвращается только цель текущего пользователя.

### 4.2. Создание/обновление цели на день (POST /api/goals/{date}/)

176. Создание цели с корректными данными (calories, proteins, fats, carbohydrates).
177. Создание цели с calories = 0 (должна быть ошибка, минимум 1).
178. Создание цели с calories < 0 (должна быть ошибка).
179. Создание цели с proteins < 0 (должна быть ошибка).
180. Создание цели с fats < 0 (должна быть ошибка).
181. Создание цели с carbohydrates < 0 (должна быть ошибка).
182. Создание цели с proteins с более чем 2 знаками после запятой.
183. Создание цели с fats с более чем 2 знаками после запятой.
184. Создание цели с carbohydrates с более чем 2 знаками после запятой.
185. Создание цели без поля calories.
186. Создание цели без поля proteins.
187. Создание цели без поля fats.
188. Создание цели без поля carbohydrates.
189. Создание цели с некорректным форматом date в URL.
190. Обновление существующей цели (upsert логика).
191. Создание цели без токена авторизации.
192. Создание цели с невалидным токеном.
193. Проверка, что после создания is_auto_calculated = False.
194. Проверка, что после создания возвращается статус 201 Created.
195. Проверка, что после обновления возвращается статус 200 OK.

### 4.3. Автоматический расчёт целей (POST /api/goals/auto-calculate/)

196. Автоматический расчёт целей с корректными данными (weight, height, age, activity_level, date).
197. Автоматический расчёт целей с указанием gender.
198. Автоматический расчёт целей с указанием goal (maintain, lose, gain).
199. Автоматический расчёт целей без поля weight.
200. Автоматический расчёт целей с weight <= 0.
201. Автоматический расчёт целей без поля height.
202. Автоматический расчёт целей с height <= 0.
203. Автоматический расчёт целей без поля age.
204. Автоматический расчёт целей с age <= 0.
205. Автоматический расчёт целей без поля activity_level.
206. Автоматический расчёт целей с невалидным activity_level.
207. Автоматический расчёт целей с activity_level = sedentary.
208. Автоматический расчёт целей с activity_level = light.
209. Автоматический расчёт целей с activity_level = moderate.
210. Автоматический расчёт целей с activity_level = active.
211. Автоматический расчёт целей с activity_level = very_active.
212. Автоматический расчёт целей с gender = male.
213. Автоматический расчёт целей с gender = female.
214. Автоматический расчёт целей с goal = maintain.
215. Автоматический расчёт целей с goal = lose.
216. Автоматический расчёт целей с goal = gain.
217. Автоматический расчёт целей без поля date.
218. Автоматический расчёт целей с некорректным форматом date.
219. Автоматический расчёт целей без токена авторизации.
220. Автоматический расчёт целей с невалидным токеном.
221. Проверка, что после расчёта is_auto_calculated = True.
222. Проверка, что расчёт создаёт или обновляет цель на указанную дату.

## 5. Управление днями

### 5.1. Получение данных за день (GET /api/days/{date}/)

223. Получение данных за день с установленной целью и блюдами.
224. Получение данных за день без установленной цели (goal = null).
225. Получение данных за день без блюд (пустые массивы для всех meal_type).
226. Получение данных за день с блюдами только в breakfast.
227. Получение данных за день с блюдами только в lunch.
228. Получение данных за день с блюдами только в dinner.
229. Получение данных за день с блюдами только в snack.
230. Получение данных за день с блюдами во всех типах приёмов пищи.
231. Получение данных за день с некорректным форматом date (не YYYY-MM-DD).
232. Получение данных за день без токена авторизации.
233. Получение данных за день с невалидным токеном.
234. Проверка структуры ответа: date, goal, meals (breakfast, lunch, dinner, snack), summary.
235. Проверка, что в summary есть: total_calories, total_proteins, total_fats, total_carbohydrates, goal_progress.
236. Проверка, что в goal_progress есть: calories_percent, proteins_percent, fats_percent, carbohydrates_percent.
237. Проверка корректности расчёта суммарных значений КБЖУ из всех блюд.
238. Проверка корректности расчёта процентов выполнения целей (если цель установлена).
239. Проверка, что проценты выполнения целей = 0, если цель не установлена.
240. Проверка, что возвращаются только блюда текущего пользователя.

## 6. Управление подписками

### 6.1. Получение информации о подписке (GET /api/subscription/)

241. Получение информации о подписке авторизованным пользователем.
242. Получение информации о подписке без токена авторизации.
243. Получение информации о подписке с невалидным токеном.
244. Получение информации о подписке для пользователя без подписки (создаётся подписка со статусом expired).
245. Получение информации о подписке со статусом active.
246. Получение информации о подписке со статусом expired.
247. Получение информации о подписке со статусом cancelled.
248. Проверка, что возвращаются поля: plan_name, status, days_remaining, end_date, auto_renew.
249. Проверка корректности расчёта days_remaining для активной подписки.
250. Проверка, что days_remaining = null для истёкшей подписки.

### 6.2. Получение списка тарифных планов (GET /api/subscription/plans/)

251. Получение списка тарифных планов без авторизации (публичный эндпоинт).
252. Получение списка тарифных планов авторизованным пользователем.
253. Проверка, что возвращаются только активные тарифные планы (is_active = True).
254. Проверка, что неактивные тарифные планы не отображаются.

### 6.3. Оплата месячной подписки (POST /api/subscription/pay-monthly/)

255. Создание платежа для месячной подписки без указания plan_id (используется базовый план).
256. Создание платежа для месячной подписки с указанием plan_id.
257. Создание платежа с несуществующим plan_id (404).
258. Создание платежа с неактивным plan_id (404).
259. Создание платежа без токена авторизации.
260. Создание платежа с невалидным токеном.
261. Проверка, что возвращаются поля: payment_id, amount, payment_url, status.
262. Проверка, что status = pending.
263. Проверка, что amount соответствует price_monthly выбранного плана.

### 6.4. Оплата годовой подписки (POST /api/subscription/pay-yearly/)

264. Создание платежа для годовой подписки без указания plan_id (используется базовый план).
265. Создание платежа для годовой подписки с указанием plan_id.
266. Создание платежа с несуществующим plan_id (404).
267. Создание платежа с неактивным plan_id (404).
268. Создание платежа без токена авторизации.
269. Создание платежа с невалидным токеном.
270. Проверка, что возвращаются поля: payment_id, amount, payment_url, status.
271. Проверка, что status = pending.
272. Проверка, что amount соответствует price_yearly выбранного плана.

### 6.5. Отключение автопродления (POST /api/subscription/disable-auto-renew/)

273. Отключение автопродления для пользователя с активной подпиской.
274. Отключение автопродления для пользователя с истёкшей подпиской.
275. Отключение автопродления без токена авторизации.
276. Отключение автопродления с невалидным токеном.
277. Проверка, что возвращаются поля: detail, auto_renew = False.
278. Проверка, что после отключения auto_renew действительно = False.

### 6.6. Включение автопродления (POST /api/subscription/enable-auto-renew/)

279. Включение автопродления для пользователя с активной подпиской.
280. Включение автопродления для пользователя с истёкшей подпиской.
281. Включение автопродления без токена авторизации.
282. Включение автопродления с невалидным токеном.
283. Проверка, что возвращаются поля: detail, auto_renew = True.
284. Проверка, что после включения auto_renew действительно = True.

### 6.7. История платежей (GET /api/subscription/payments/)

285. Получение истории платежей авторизованным пользователем.
286. Получение истории платежей для пользователя без платежей (пустой список).
287. Получение истории платежей с пагинацией (query параметр ?page=1).
288. Получение истории платежей с кастомным размером страницы (query параметр ?page_size=10).
289. Получение истории платежей без токена авторизации.
290. Получение истории платежей с невалидным токеном.
291. Проверка, что платежи отсортированы по дате (новые первыми).
292. Проверка, что возвращаются только платежи текущего пользователя.
293. Проверка структуры ответа: count, next, previous, results.
294. Проверка, что в results есть поля: id, plan_name, amount, payment_type, status, created_at.

### 6.8. Webhook для обработки платежей (POST /api/subscription/webhook/)

295. Обработка webhook с корректными данными и статусом completed.
296. Обработка webhook с корректными данными и статусом failed.
297. Обработка webhook без transaction_id (400).
298. Обработка webhook с несуществующим transaction_id (возвращается ok, но платёж не обновляется).
299. Обработка webhook без авторизации (публичный эндпоинт).
300. Проверка, что при статусе completed подписка активируется (status = active).
301. Проверка, что при статусе completed устанавливаются start_date и end_date.
302. Проверка, что для месячной подписки end_date = start_date + 30 дней.
303. Проверка, что для годовой подписки end_date = start_date + 365 дней.
304. Проверка, что статус платежа обновляется на completed.

## 7. Общие сценарии

### 7.1. Безопасность и авторизация

305. Доступ к защищённым эндпоинтам без токена авторизации (401).
306. Доступ к защищённым эндпоинтам с невалидным токеном (401).
307. Доступ к защищённым эндпоинтам с истёкшим токеном (401).
308. Доступ к данным другого пользователя (403 или 404).
309. Попытка обновить данные другого пользователя (403).
310. Попытка удалить данные другого пользователя (403).

### 7.2. Валидация данных

311. Отправка некорректного JSON в теле запроса.
312. Отправка пустого тела запроса для эндпоинтов, требующих данных.
313. Отправка данных с неправильными типами (строка вместо числа).
314. Отправка данных с превышением максимальных значений.
315. Отправка данных с отрицательными значениями для полей, где это недопустимо.

### 7.3. Граничные случаи

316. Работа с очень большими значениями (например, calories = 999999).
317. Работа с очень маленькими значениями (например, proteins = 0.01).
318. Работа с датами в далёком прошлом (например, 1900-01-01).
319. Работа с датами в далёком будущем (например, 2100-01-01).
320. Работа с пустыми строками в полях, где это недопустимо.
321. Работа с пробелами в начале и конце строковых полей.

### 7.4. Производительность

322. Получение списка блюд с большим количеством записей (проверка пагинации).
323. Получение данных за день с большим количеством блюд (проверка производительности).
324. Получение истории платежей с большим количеством записей (проверка пагинации).

### 7.5. Интеграция

325. Проверка корректности работы всех эндпоинтов в последовательности (полный пользовательский сценарий).
326. Регистрация → Вход → Создание блюда → Создание цели → Получение данных за день.
327. Создание платежа → Webhook с completed → Проверка активации подписки.

## 8. Безопасность (конфигурация и защита)

328. Проверка, что SECRET_KEY берётся из переменной окружения и не равен значению по умолчанию.
329. Проверка, что DEBUG=False в production окружении (через переменные окружения).
330. Проверка, что ALLOWED_HOSTS в production не пустой и содержит боевые домены.
331. Проверка, что CORS_ALLOWED_ORIGINS задаётся через переменные окружения и допускает только доверенные фронтенды.
332. Проверка наличия security headers: X-Frame-Options=DENY, X-Content-Type-Options=nosniff, HSTS (SECURE_HSTS_SECONDS > 0 при DEBUG=False).
333. Проверка HTTPS-редиректа (SECURE_SSL_REDIRECT=True в production) и secure cookies (SESSION_COOKIE_SECURE, CSRF_COOKIE_SECURE).
334. Проверка ограничения размера запроса DATA_UPLOAD_MAX_MEMORY_SIZE (ошибка при загрузке > 10 МБ).
335. Throttle регистрации: более 5 запросов в час с одного IP должны получать 429.
336. Throttle логина: более 10 запросов за 15 минут с одного IP должны получать 429.
337. Throttle распознавания блюд: более 10 запросов в минуту и более 100 в сутки с одного IP должны получать 429.
338. Webhook: корректная подпись (X-Webhook-Signature) — 200 OK, обновление платежа и подписки.
339. Webhook: некорректная подпись — 401 Unauthorized, изменения не применяются.
340. Webhook: несовпадение суммы payment.amount и полученной amount — 400 Bad Request.
341. Проверка, что после смены пароля все существующие refresh токены пользователя инвалидируются (blacklist) и не работают.
342. Проверка, что .env не попадает в репозиторий (.gitignore содержит .env).

## 9. Документация API (Swagger/OpenAPI)

343. Проверка доступности Swagger UI по адресу /api/schema/swagger-ui/.
344. Проверка доступности ReDoc по адресу /api/schema/redoc/.
345. Проверка доступности OpenAPI схемы в JSON по адресу /api/schema/.
346. Проверка, что все эндпоинты отображаются в Swagger документации.
347. Проверка, что для каждого эндпоинта указаны корректные методы (GET, POST, PATCH, DELETE).
348. Проверка, что для каждого эндпоинта есть описание (summary и description).
349. Проверка, что для каждого эндпоинта указаны параметры запроса (path, query, body).
350. Проверка, что для каждого эндпоинта указаны типы данных параметров.
351. Проверка, что для каждого эндпоинта указаны примеры запросов.
352. Проверка, что для каждого эндпоинта указаны возможные коды ответов (200, 201, 400, 401, 403, 404, 500).
353. Проверка, что для каждого кода ответа есть описание и примеры.
354. Проверка, что схемы моделей (User, Profile, Dish, Goal, Subscription, Payment) корректно отображаются.
355. Проверка, что в Swagger UI можно протестировать эндпоинты с авторизацией (кнопка Authorize).
356. Проверка, что JWT токен корректно передаётся через Swagger UI.
357. Проверка, что Swagger UI работает в production (если документация публичная).
358. Проверка, что Swagger UI защищена паролем или отключена в production (если документация приватная).

## 10. Логирование и мониторинг

359. Проверка, что логи записываются в файл (logs/django.log или аналогичный).
360. Проверка, что логи записываются в консоль (для Docker/Kubernetes).
361. Проверка, что логи содержат timestamp, уровень (INFO, WARNING, ERROR), сообщение.
362. Проверка, что логируются все HTTP запросы (метод, URL, статус код, время выполнения).
363. Проверка, что логируются ошибки 4xx и 5xx с полным traceback.
364. Проверка, что логируются критические операции (регистрация, вход, создание платежа, webhook).
365. Проверка, что в логах не записываются чувствительные данные (пароли, токены, данные карт).
366. Проверка, что логи ротируются (не растут бесконечно) - используется RotatingFileHandler или TimedRotatingFileHandler.
367. Проверка, что уровень логирования настраивается через переменные окружения (LOG_LEVEL=INFO/DEBUG/WARNING/ERROR).
368. Проверка, что логи структурированы (JSON формат) для удобства парсинга (опционально).
369. Проверка интеграции с системами мониторинга (Sentry, Datadog, CloudWatch) - если используется.
370. Проверка, что Sentry получает уведомления об ошибках 5xx (если настроен).
371. Проверка, что в Sentry не попадают чувствительные данные (используется before_send для фильтрации).

## 11. Обработка ошибок и исключений

372. Проверка, что все необработанные исключения возвращают 500 Internal Server Error.
373. Проверка, что 500 ошибки возвращают JSON с полем "detail" (не HTML).
374. Проверка, что в production не возвращается полный traceback в ответе (DEBUG=False).
375. Проверка, что кастомные исключения обрабатываются корректно (например, PaymentError, RecognitionError).
376. Проверка, что ValidationError возвращает 400 с понятными сообщениями об ошибках.
377. Проверка, что ошибки базы данных (IntegrityError, OperationalError) обрабатываются корректно.
378. Проверка, что ошибки внешних API (распознавание изображений, платежи) обрабатываются с retry логикой.
379. Проверка, что timeout внешних API не приводит к зависанию запроса (установлены таймауты).
380. Проверка, что при недоступности внешнего API возвращается 503 Service Unavailable.
381. Проверка, что при недоступности базы данных возвращается 503 Service Unavailable.
382. Проверка, что существует custom 404 страница/ответ для несуществующих эндпоинтов.
383. Проверка, что существует custom 500 страница/ответ для внутренних ошибок.

## 12. База данных

### 12.1. Миграции

384. Проверка, что все миграции применены (python manage.py showmigrations - все [X]).
385. Проверка, что нет неприменённых миграций (python manage.py migrate --check).
386. Проверка, что миграции можно откатить (python manage.py migrate <app> <previous_migration>).
387. Проверка, что миграции не содержат необратимых операций без предупреждений.
388. Проверка, что миграции тестируются на копии production данных перед применением.
389. Проверка, что миграции не удаляют данные без явного подтверждения.
390. Проверка, что миграции выполняются быстро (< 1 минуты для больших таблиц).
391. Проверка, что миграции не блокируют таблицы на длительное время (используется CONCURRENTLY для индексов в PostgreSQL).

### 12.2. Индексы и производительность

392. Проверка, что созданы индексы для часто запрашиваемых полей (user_id, date, meal_type).
393. Проверка, что созданы индексы для полей, используемых в фильтрации и сортировке.
394. Проверка, что созданы составные индексы для часто используемых комбинаций полей.
395. Проверка, что используется select_related для ForeignKey связей (избегание N+1 запросов).
396. Проверка, что используется prefetch_related для ManyToMany и обратных ForeignKey связей.
397. Проверка, что медленные запросы (> 100ms) оптимизированы.
398. Проверка, что используется пагинация для всех списков (избегание загрузки всех записей).
399. Проверка, что используется кэширование для часто запрашиваемых данных (опционально).

### 12.3. Бэкапы и восстановление

400. Проверка, что настроены автоматические бэкапы базы данных (ежедневные/еженедельные).
401. Проверка, что бэкапы хранятся в безопасном месте (отдельный сервер, S3, облачное хранилище).
402. Проверка, что бэкапы шифруются при хранении.
403. Проверка, что процесс восстановления из бэкапа протестирован и работает.
404. Проверка, что бэкапы хранятся минимум 30 дней.
405. Проверка, что существует процедура восстановления после катастрофического сбоя (disaster recovery plan).

## 13. Статические файлы и медиа

406. Проверка, что STATIC_ROOT настроен корректно.
407. Проверка, что MEDIA_ROOT настроен корректно.
408. Проверка, что python manage.py collectstatic собирает все статические файлы без ошибок.
409. Проверка, что статические файлы доступны по URL /static/.
410. Проверка, что медиа файлы доступны по URL /media/.
411. Проверка, что статические файлы раздаются через веб-сервер (Nginx, Apache), а не Django.
412. Проверка, что медиа файлы раздаются через веб-сервер или CDN.
413. Проверка, что загруженные изображения сохраняются в MEDIA_ROOT.
414. Проверка, что загруженные изображения доступны для скачивания по URL.
415. Проверка, что существует ограничение на размер загружаемых файлов (DATA_UPLOAD_MAX_MEMORY_SIZE).
416. Проверка, что существует ограничение на типы загружаемых файлов (только изображения).
417. Проверка, что загруженные файлы имеют уникальные имена (избегание перезаписи).
418. Проверка, что неиспользуемые медиа файлы периодически удаляются (cleanup task).

## 14. Email уведомления

419. Проверка, что EMAIL_BACKEND настроен корректно (SMTP, SendGrid, AWS SES).
420. Проверка, что EMAIL_HOST, EMAIL_PORT, EMAIL_USE_TLS настроены через переменные окружения.
421. Проверка, что EMAIL_HOST_USER и EMAIL_HOST_PASSWORD настроены и работают.
422. Проверка, что DEFAULT_FROM_EMAIL настроен корректно.
423. Проверка отправки email при регистрации (welcome email) - если реализовано.
424. Проверка отправки email при сбросе пароля (password reset) - если реализовано.
425. Проверка отправки email при успешном платеже (payment confirmation) - если реализовано.
426. Проверка, что email отправляются асинхронно (Celery, background tasks) и не блокируют запросы.
427. Проверка, что ошибки отправки email логируются, но не приводят к падению приложения.
428. Проверка, что email шаблоны корректно рендерятся (HTML и plain text версии).
429. Проверка, что в email не попадают чувствительные данные (пароли, токены).

## 15. Переменные окружения и конфигурация

430. Проверка, что все секретные данные (SECRET_KEY, DB_PASSWORD, API_KEYS) берутся из переменных окружения.
431. Проверка, что существует файл .env.example с примерами всех необходимых переменных.
432. Проверка, что .env файл добавлен в .gitignore и не попадает в репозиторий.
433. Проверка, что все обязательные переменные окружения документированы.
434. Проверка, что приложение падает с понятной ошибкой при отсутствии обязательных переменных.
435. Проверка, что DATABASE_URL парсится корректно (dj-database-url).
436. Проверка, что ALLOWED_HOSTS настраивается через переменные окружения (список через запятую).
437. Проверка, что CORS_ALLOWED_ORIGINS настраивается через переменные окружения.
438. Проверка, что DEBUG берётся из переменной окружения и по умолчанию = False.
439. Проверка, что в production DEBUG=False.
440. Проверка, что в development DEBUG=True для удобства разработки.

## 16. Docker и контейнеризация

441. Проверка, что существует Dockerfile для сборки образа приложения.
442. Проверка, что Dockerfile использует multi-stage build для уменьшения размера образа.
443. Проверка, что Dockerfile использует non-root пользователя для запуска приложения.
444. Проверка, что существует docker-compose.yml для локальной разработки.
445. Проверка, что docker-compose.yml содержит сервисы: web, db, redis (если используется).
446. Проверка, что docker-compose up запускает все сервисы без ошибок.
447. Проверка, что приложение в Docker контейнере доступно по localhost:8000.
448. Проверка, что миграции применяются автоматически при запуске контейнера (entrypoint.sh).
449. Проверка, что статические файлы собираются автоматически при запуске контейнера.
450. Проверка, что volumes настроены для сохранения данных (БД, медиа файлы).
451. Проверка, что переменные окружения передаются в контейнер через .env файл или docker-compose.
452. Проверка, что Docker образ собирается без ошибок (docker build -t calorio-api .).
453. Проверка, что Docker образ имеет разумный размер (< 500 MB).
454. Проверка, что Docker образ использует официальные базовые образы (python:3.11-slim).
455. Проверка, что .dockerignore настроен для исключения ненужных файлов (.git, __pycache__, .env).

## 17. CI/CD

456. Проверка, что существует CI/CD конфигурация (GitHub Actions, GitLab CI, Jenkins).
457. Проверка, что CI запускает линтеры (flake8, black, isort) при каждом коммите.
458. Проверка, что CI запускает тесты (pytest, unittest) при каждом коммите.
459. Проверка, что CI проверяет покрытие кода тестами (coverage).
460. Проверка, что CI проверяет безопасность зависимостей (safety, bandit).
461. Проверка, что CI собирает Docker образ при каждом коммите.
462. Проверка, что CI публикует Docker образ в registry (Docker Hub, AWS ECR, GCR).
463. Проверка, что CD автоматически деплоит на staging при merge в develop ветку.
464. Проверка, что CD автоматически деплоит на production при merge в main ветку (с подтверждением).
465. Проверка, что CD откатывает деплой при ошибках (rollback).
466. Проверка, что существует процесс code review перед merge в main ветку.
467. Проверка, что существует процесс тестирования на staging перед production деплоем.

## 18. Health Checks и Readiness Probes

468. Проверка, что существует эндпоинт /health/ для health check.
469. Проверка, что /health/ возвращает 200 OK, если приложение работает.
470. Проверка, что /health/ проверяет доступность базы данных.
471. Проверка, что /health/ проверяет доступность Redis (если используется).
472. Проверка, что /health/ проверяет доступность внешних API (опционально).
473. Проверка, что /health/ возвращает 503 Service Unavailable, если какой-то компонент недоступен.
474. Проверка, что существует эндпоинт /ready/ для readiness probe (для Kubernetes).
475. Проверка, что /ready/ возвращает 200 OK, если приложение готово принимать запросы.
476. Проверка, что health checks не требуют авторизации (публичные).
477. Проверка, что health checks выполняются быстро (< 1 секунды).
478. Проверка, что health checks логируются для мониторинга.

## 19. Производительность и нагрузочное тестирование

479. Проверка, что приложение выдерживает 100 одновременных запросов без ошибок.
480. Проверка, что приложение выдерживает 1000 запросов в минуту без деградации производительности.
481. Проверка, что время ответа на простые запросы (GET /api/profile/) < 100ms.
482. Проверка, что время ответа на сложные запросы (GET /api/days/{date}/) < 500ms.
483. Проверка, что распознавание изображений не блокирует другие запросы (асинхронная обработка).
484. Проверка, что база данных выдерживает нагрузку (connection pooling настроен).
485. Проверка, что используется connection pooling для базы данных (CONN_MAX_AGE > 0).
486. Проверка, что используется кэширование для часто запрашиваемых данных (Redis, Memcached).
487. Проверка, что статические файлы раздаются с кэшированием (Cache-Control headers).
488. Проверка, что API rate limiting настроен корректно (throttling).
489. Проверка, что приложение масштабируется горизонтально (можно запустить несколько инстансов).
490. Проверка, что используется load balancer для распределения нагрузки (Nginx, AWS ALB).

## 20. Безопасность (дополнительные проверки)

491. Проверка, что используется HTTPS в production (SSL/TLS сертификат).
492. Проверка, что HTTP автоматически редиректится на HTTPS (SECURE_SSL_REDIRECT=True).
493. Проверка, что используется HSTS (HTTP Strict Transport Security) - SECURE_HSTS_SECONDS > 0.
494. Проверка, что cookies помечены как Secure и HttpOnly.
495. Проверка, что используется CSRF защита для всех POST/PUT/PATCH/DELETE запросов.
496. Проверка, что CSRF токен корректно передаётся и проверяется.
497. Проверка, что используется защита от XSS (Content-Security-Policy headers).
498. Проверка, что используется защита от clickjacking (X-Frame-Options: DENY).
499. Проверка, что используется защита от MIME type sniffing (X-Content-Type-Options: nosniff).
500. Проверка, что SQL инъекции невозможны (используется ORM, не raw SQL).
501. Проверка, что пользовательский ввод санитизируется и валидируется.
502. Проверка, что файлы загружаются в безопасное место (не в STATIC_ROOT).
503. Проверка, что загруженные файлы не могут быть выполнены (правильные MIME types).
504. Проверка, что используется rate limiting для предотвращения DDoS атак.
505. Проверка, что используется защита от brute force атак на логин (throttling).
506. Проверка, что пароли хранятся в зашифрованном виде (Django password hashers).
507. Проверка, что используется сильный алгоритм хеширования паролей (PBKDF2, Argon2, bcrypt).
508. Проверка, что JWT токены имеют разумное время жизни (access: 15 минут, refresh: 7 дней).
509. Проверка, что refresh токены могут быть отозваны (blacklist).
510. Проверка, что API ключи для внешних сервисов хранятся в переменных окружения, а не в коде.

## 21. Документация проекта

511. Проверка, что существует README.md с описанием проекта.
512. Проверка, что README содержит инструкции по установке и запуску.
513. Проверка, что README содержит список зависимостей и требований.
514. Проверка, что README содержит примеры использования API.
515. Проверка, что существует документация по архитектуре проекта.
516. Проверка, что существует документация по моделям данных (ER диаграмма).
517. Проверка, что существует документация по API эндпоинтам (или ссылка на Swagger).
518. Проверка, что существует CHANGELOG.md с историей изменений.
519. Проверка, что существует CONTRIBUTING.md с правилами для контрибьюторов.
520. Проверка, что существует LICENSE файл с лицензией проекта.

## 22. Мониторинг и алертинг

521. Проверка, что настроен мониторинг доступности приложения (uptime monitoring).
522. Проверка, что настроен мониторинг производительности (response time, throughput).
523. Проверка, что настроен мониторинг ошибок (error rate, 5xx errors).
524. Проверка, что настроен мониторинг ресурсов (CPU, память, диск).
525. Проверка, что настроен мониторинг базы данных (connections, slow queries).
526. Проверка, что настроены алерты при недоступности приложения.
527. Проверка, что настроены алерты при высоком error rate (> 1%).
528. Проверка, что настроены алерты при высокой нагрузке (CPU > 80%, память > 90%).
529. Проверка, что настроены алерты при заполнении диска (> 80%).
530. Проверка, что алерты отправляются в нужные каналы (email, Slack, PagerDuty).

## 23. Compliance и юридические требования

531. Проверка, что существует Privacy Policy (политика конфиденциальности).
532. Проверка, что существует Terms of Service (условия использования).
533. Проверка, что пользователи соглашаются с Terms of Service при регистрации.
534. Проверка, что персональные данные обрабатываются согласно GDPR (если применимо).
535. Проверка, что пользователи могут запросить удаление своих данных (right to be forgotten).
536. Проверка, что пользователи могут экспортировать свои данные (data portability).
537. Проверка, что существует процесс обработки запросов на удаление данных.
538. Проверка, что существует процесс уведомления пользователей о изменениях в Privacy Policy.

## 24. Финальная проверка перед деплоем

539. Проверка, что все тесты проходят успешно (pytest, unittest).
540. Проверка, что покрытие кода тестами > 80%.
541. Проверка, что линтеры не выдают критических ошибок (flake8, pylint).
542. Проверка, что код отформатирован согласно стандартам (black, isort).
543. Проверка, что все TODO и FIXME в коде исправлены или задокументированы.
544. Проверка, что все миграции применены на production базе данных.
545. Проверка, что бэкап production базы данных создан перед деплоем.
546. Проверка, что все переменные окружения настроены на production сервере.
547. Проверка, что SSL сертификат установлен и действителен.
548. Проверка, что DNS записи настроены корректно.
549. Проверка, что firewall настроен корректно (открыты только необходимые порты).
550. Проверка, что мониторинг и алертинг работают.
551. Проверка, что существует план отката (rollback plan) на случай проблем.
552. Проверка, что команда готова к мониторингу после деплоя (on-call).
553. Проверка, что документация обновлена и актуальна.
554. Проверка, что stakeholders уведомлены о предстоящем деплое.
555. Проверка, что запланировано время для деплоя (maintenance window).
556. Проверка, что существует план коммуникации с пользователями о downtime (если требуется).

## 25. Post-deployment проверки

557. Проверка, что приложение доступно по production URL.
558. Проверка, что все основные эндпоинты работают корректно (smoke tests).
559. Проверка, что регистрация и вход работают.
560. Проверка, что создание блюд работает.
561. Проверка, что распознавание изображений работает.
562. Проверка, что платежи работают (тестовый платёж).
563. Проверка, что webhook обрабатывается корректно.
564. Проверка, что email уведомления отправляются.
565. Проверка, что логи пишутся корректно.
566. Проверка, что мониторинг показывает здоровое состояние приложения.
567. Проверка, что нет критических ошибок в логах.
568. Проверка, что производительность соответствует ожиданиям (response time).
569. Проверка, что SSL сертификат работает корректно (https://).
570. Проверка, что CORS настроен корректно для фронтенда.
571. Проверка, что Swagger документация доступна (если публичная).
572. Проверка, что health checks возвращают 200 OK.
573. Проверка, что нет утечек памяти (мониторинг памяти в течение нескольких часов).
574. Проверка, что база данных работает стабильно (нет блокировок, deadlocks).
575. Проверка, что бэкапы создаются автоматически.
576. Проверка, что алерты работают (тестовый алерт).
577. Проверка, что rollback plan протестирован и работает (опционально).
578. Проверка, что пользователи могут успешно использовать приложение (user acceptance testing).
579. Проверка, что нет критических багов, о которых сообщают пользователи.
580. Проверка, что команда готова к поддержке и быстрому реагированию на проблемы.

