# Отчет об аудите информационной безопасности

**Аудитор:** Information Security Auditor  
**Дата проведения:** 2025-01-27  
**Проект:** Calorio API  
**Версия:** 1.0.0

---

## Резюме

Проведен комплексный аудит безопасности REST API сервиса подсчёта калорий. Выявлено **23 уязвимости** различной степени критичности. Проект использует Django REST Framework с JWT аутентификацией, однако содержит ряд критических уязвимостей, которые необходимо устранить перед релизом в production.

---

## Уязвимости

### КРИТИЧЕСКИЕ (Critical)

#### 1. SECRET_KEY захардкожен в коде
**Описание:** Секретный ключ Django захардкожен в файле `settings.py` вместо использования переменных окружения. Это критическая уязвимость, так как ключ может быть скомпрометирован при утечке кода.

**Расположение:** `calorio_api/settings.py:28`

**Код:**
```python
SECRET_KEY = 'django-insecure-n%d*14o_j&=vho++!25id#ffg$qmb3#^q1or81=jm7+qt#6i7$'
```

**Риски:**
- Компрометация всех сессий пользователей
- Возможность подделки JWT токенов
- Нарушение целостности данных

**Рекомендации:**
- Использовать переменную окружения: `SECRET_KEY = os.getenv('SECRET_KEY')`
- Генерировать новый SECRET_KEY для production
- Никогда не коммитить SECRET_KEY в репозиторий

**Приоритет:** Критический  
**Статус:** Открыта

---

#### 2. DEBUG режим включен в production
**Описание:** В настройках проекта `DEBUG = True`, что недопустимо для production окружения. В режиме отладки Django раскрывает детальную информацию об ошибках, структуру БД и другую чувствительную информацию.

**Расположение:** `calorio_api/settings.py:31`

**Код:**
```python
DEBUG = True
```

**Риски:**
- Утечка информации о структуре приложения
- Раскрытие путей к файлам
- Отображение SQL запросов и стека вызовов
- Упрощение атак на приложение

**Рекомендации:**
- Установить `DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'`
- Использовать отдельные настройки для development и production
- Настроить логирование ошибок без раскрытия деталей

**Приоритет:** Критический  
**Статус:** Открыта

---

#### 3. ALLOWED_HOSTS пустой
**Описание:** Параметр `ALLOWED_HOSTS` не настроен, что позволяет атакам Host Header Injection и может привести к кэш-отравлению.

**Расположение:** `calorio_api/settings.py:33`

**Код:**
```python
ALLOWED_HOSTS = []
```

**Риски:**
- Host Header Injection атаки
- Кэш-отравление
- Подмена домена в запросах

**Рекомендации:**
- Установить `ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', '').split(',')`
- Указать конкретные домены в переменных окружения
- Для production: `ALLOWED_HOSTS = ['api.calorio.app', 'www.calorio.app']`

**Приоритет:** Критический  
**Статус:** Открыта

---

#### 4. Webhook без проверки подписи
**Описание:** Эндпоинт webhook для обработки платежей не проверяет подпись запроса от платёжного провайдера. Любой может отправить поддельный запрос и активировать подписку.

**Расположение:** `subscriptions/views.py:246-298`

**Код:**
```python
class WebhookView(APIView):
    permission_classes = [permissions.AllowAny]  # Webhook не требует аутентификации
    
    def post(self, request):
        # В реальном приложении здесь будет проверка подписи запроса
        # и обработка данных от конкретного провайдера
```

**Риски:**
- Активация подписок без оплаты
- Манипуляция статусами платежей
- Финансовые потери

**Рекомендации:**
- Реализовать проверку подписи запроса (HMAC, RSA и т.д.)
- Проверять IP адреса платёжного провайдера
- Валидировать все данные перед обновлением статуса
- Логировать все webhook запросы

**Приоритет:** Критический  
**Статус:** Открыта

---

### ВЫСОКИЕ (High)

#### 5. Отсутствие защиты от timing attacks при логине
**Описание:** В функции логина используется последовательная проверка существования пользователя и пароля, что позволяет злоумышленнику определить существование email по времени ответа.

**Расположение:** `users/views.py:66-77`

**Код:**
```python
try:
    user = User.objects.get(email=email)
except User.DoesNotExist:
    return Response({
        'detail': 'Неверный email или пароль.'
    }, status=status.HTTP_401_UNAUTHORIZED)

if not user.check_password(password):
    return Response({
        'detail': 'Неверный email или пароль.'
    }, status=status.HTTP_401_UNAUTHORIZED)
```

**Риски:**
- Перечисление пользователей (user enumeration)
- Утечка информации о существующих аккаунтах
- Упрощение брутфорс атак

**Рекомендации:**
- Всегда выполнять проверку пароля, даже если пользователь не найден
- Использовать `authenticate()` вместо ручной проверки
- Добавить искусственную задержку для выравнивания времени ответа

**Приоритет:** Высокий  
**Статус:** Открыта

---

#### 6. Отсутствие rate limiting на критичных эндпоинтах
**Описание:** Эндпоинты регистрации и логина не имеют специальных ограничений по частоте запросов, что позволяет проводить брутфорс атаки и массовую регистрацию.

**Расположение:** `users/views.py:23-100`

**Риски:**
- Брутфорс атаки на пароли
- Массовая регистрация ботов
- DoS атаки на сервер

**Рекомендации:**
- Добавить кастомный throttle для регистрации (например, 5 запросов в час с одного IP)
- Добавить кастомный throttle для логина (например, 10 попыток в 15 минут)
- Использовать CAPTCHA после нескольких неудачных попыток
- Блокировать IP после множественных неудачных попыток

**Приоритет:** Высокий  
**Статус:** Открыта

---

#### 7. Отсутствие ограничений на размер запросов
**Описание:** Нет ограничений на размер тела запроса, что может привести к DoS атакам через отправку больших payload.

**Расположение:** Настройки Django/DRF

**Риски:**
- DoS атаки через большие запросы
- Исчерпание памяти сервера
- Замедление работы приложения

**Рекомендации:**
- Настроить `DATA_UPLOAD_MAX_MEMORY_SIZE` в settings.py
- Ограничить размер для эндпоинта распознавания изображений (уже есть 10 МБ, но нужно проверить)
- Использовать nginx/аналоги для ограничения размера запросов на уровне веб-сервера

**Приоритет:** Высокий  
**Статус:** Открыта

---

#### 8. CORS настроен только для localhost
**Описание:** CORS разрешён только для localhost, что не позволит работать с production фронтендом.

**Расположение:** `calorio_api/settings.py:231-234`

**Код:**
```python
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
]
```

**Риски:**
- Невозможность работы с production фронтендом
- Неправильная настройка может привести к CORS уязвимостям

**Рекомендации:**
- Использовать переменные окружения для CORS_ALLOWED_ORIGINS
- Для production: `CORS_ALLOWED_ORIGINS = os.getenv('CORS_ALLOWED_ORIGINS', '').split(',')`
- Убедиться, что `CORS_ALLOW_CREDENTIALS = True` только при необходимости
- Рассмотреть использование `CORS_ALLOWED_ORIGIN_REGEXES` для поддоменов

**Приоритет:** Высокий  
**Статус:** Открыта

---

#### 9. Отсутствие Security Headers
**Описание:** Не настроены важные security headers (HSTS, CSP, X-Content-Type-Options и др.), что снижает защиту от различных атак.

**Расположение:** `calorio_api/settings.py`

**Риски:**
- XSS атаки
- Clickjacking
- MIME type sniffing
- Man-in-the-middle атаки

**Рекомендации:**
- Установить `django-cors-headers` уже установлен, но нужно добавить:
  - `SECURE_BROWSER_XSS_FILTER = True`
  - `SECURE_CONTENT_TYPE_NOSNIFF = True`
  - `X_FRAME_OPTIONS = 'DENY'`
  - `SECURE_HSTS_SECONDS = 31536000` (для HTTPS)
  - `SECURE_HSTS_INCLUDE_SUBDOMAINS = True`
  - `SECURE_HSTS_PRELOAD = True`
- Использовать `django-security` или настроить через middleware

**Приоритет:** Высокий  
**Статус:** Открыта

---

#### 10. Отсутствие валидации максимальной длины для некоторых полей
**Описание:** В некоторых сериализаторах отсутствует явная валидация максимальной длины строковых полей, что может привести к DoS через большие значения.

**Расположение:** Различные сериализаторы

**Примеры:**
- `DishSerializer.name` - есть `max_length=255` в модели, но нужно проверить валидацию в сериализаторе
- `image_base64` в `DishRecognitionSerializer` - проверяется размер декодированного изображения, но не длина строки base64

**Риски:**
- DoS через отправку очень длинных строк
- Переполнение памяти при обработке
- Проблемы с производительностью

**Рекомендации:**
- Добавить явную валидацию `max_length` во всех CharField сериализаторов
- Ограничить длину base64 строки перед декодированием
- Использовать `MaxLengthValidator` где необходимо

**Приоритет:** Высокий  
**Статус:** Открыта

---

### СРЕДНИЕ (Medium)

#### 11. Отсутствие защиты от IDOR в некоторых эндпоинтах
**Описание:** Хотя в большинстве эндпоинтов есть проверка принадлежности ресурса пользователю, нужно убедиться, что все эндпоинты защищены от Insecure Direct Object Reference.

**Расположение:** Различные views

**Проверенные эндпоинты:**
- ✅ `DishViewSet.get_object()` - есть проверка
- ✅ `ProfileView` - использует `request.user`
- ⚠️ `DailyGoalView` - фильтрует по `user=request.user`, но нужно проверить все операции
- ⚠️ `PaymentHistoryView` - фильтрует по `user=self.request.user`

**Риски:**
- Доступ к данным других пользователей
- Манипуляция чужими ресурсами

**Рекомендации:**
- Провести аудит всех эндпоинтов на наличие проверки принадлежности
- Использовать `get_object_or_404` с фильтрацией по пользователю
- Добавить тесты на IDOR уязвимости

**Приоритет:** Средний  
**Статус:** Требует проверки

---

#### 12. Отсутствие валидации на SQL инъекции в raw запросах
**Описание:** Хотя Django ORM защищает от SQL инъекций, нужно убедиться, что нет использования `raw()` или `extra()` без параметризации.

**Расположение:** Весь код проекта

**Статус проверки:** ✅ Используется только Django ORM, raw SQL запросов не обнаружено

**Риски:**
- SQL инъекции при использовании raw запросов

**Рекомендации:**
- Продолжать использовать только Django ORM
- При необходимости использовать raw запросы - всегда параметризовать
- Проводить code review на наличие raw SQL

**Приоритет:** Средний  
**Статус:** Нет уязвимости (профилактика)

---

#### 13. Логирование чувствительных данных
**Описание:** В логах могут попадать чувствительные данные (пароли, токены, персональные данные).

**Расположение:** `core/error_handlers.py`, `calorio_api/settings.py:189-228`

**Риски:**
- Утечка паролей в логах
- Утечка JWT токенов
- Нарушение GDPR/законов о защите данных

**Рекомендации:**
- Маскировать пароли в логах (заменять на `***`)
- Не логировать полные токены
- Не логировать персональные данные без необходимости
- Использовать разные уровни логирования для production
- Настроить ротацию и очистку логов

**Приоритет:** Средний  
**Статус:** Открыта

---

#### 14. Отсутствие защиты от массовых операций
**Описание:** Нет ограничений на количество объектов, которые можно создать за один запрос или за период времени.

**Расположение:** `core/views.py` (DishViewSet, DailyGoalView)

**Риски:**
- DoS через создание большого количества записей
- Исчерпание ресурсов БД
- Злоупотребление API

**Рекомендации:**
- Добавить ограничения на количество блюд в день (например, 100)
- Ограничить частоту создания целей
- Мониторить аномальную активность пользователей

**Приоритет:** Средний  
**Статус:** Открыта

---

#### 15. Отсутствие валидации на XSS в ответах API
**Описание:** Хотя это REST API и не рендерит HTML, данные пользователей возвращаются как есть, что может быть проблемой если API используется веб-интерфейсом.

**Расположение:** Все сериализаторы

**Риски:**
- XSS атаки через данные API
- Инъекция вредоносного контента

**Рекомендации:**
- Санитизировать пользовательский ввод (удалять HTML теги)
- Экранировать специальные символы в ответах
- Использовать `bleach` или аналоги для очистки HTML
- Настроить Content Security Policy на фронтенде

**Приоритет:** Средний  
**Статус:** Открыта

---

#### 16. Отсутствие защиты от CSRF для Session Authentication
**Описание:** В настройках DRF включена `SessionAuthentication`, но для REST API обычно используется только JWT. CSRF защита может быть избыточной, но нужно убедиться в правильной настройке.

**Расположение:** `calorio_api/settings.py:145-148`

**Код:**
```python
'DEFAULT_AUTHENTICATION_CLASSES': [
    'rest_framework_simplejwt.authentication.JWTAuthentication',
    'rest_framework.authentication.SessionAuthentication',
],
```

**Риски:**
- CSRF атаки при использовании сессий
- Неправильная конфигурация может блокировать легитимные запросы

**Рекомендации:**
- Если используется только JWT, убрать `SessionAuthentication`
- Если нужны сессии, убедиться что CSRF middleware правильно настроен
- Для API-only приложений можно отключить CSRF для API endpoints

**Приоритет:** Средний  
**Статус:** Требует уточнения

---

### НИЗКИЕ (Low)

#### 17. Отсутствие принудительного HTTPS
**Описание:** Нет настроек для принудительного использования HTTPS в production.

**Расположение:** `calorio_api/settings.py`

**Риски:**
- Перехват данных в открытом виде
- Man-in-the-middle атаки

**Рекомендации:**
- Установить `SECURE_SSL_REDIRECT = True` для production
- Настроить `SESSION_COOKIE_SECURE = True`
- Настроить `CSRF_COOKIE_SECURE = True`
- Использовать reverse proxy (nginx) для SSL терминации

**Приоритет:** Низкий  
**Статус:** Открыта

---

#### 18. Отсутствие валидации на переполнение числовых полей
**Описание:** Хотя Django модели имеют ограничения на `max_digits`, нужно убедиться, что валидация работает на уровне API.

**Расположение:** Сериализаторы с DecimalField

**Статус:** ✅ В большинстве случаев валидация есть (например, `max_digits=6` для КБЖУ)

**Риски:**
- Переполнение при очень больших значениях
- Проблемы с производительностью

**Рекомендации:**
- Убедиться, что все DecimalField имеют `max_digits`
- Добавить валидацию на уровне сериализаторов
- Провести тестирование граничных значений

**Приоритет:** Низкий  
**Статус:** Частично исправлено

---

#### 19. Отсутствие защиты от перечисления пользователей при регистрации
**Описание:** При регистрации с существующим email возвращается конкретная ошибка, что позволяет определить существование аккаунта.

**Расположение:** `users/serializers.py:39-43`

**Код:**
```python
def validate_email(self, value):
    """Валидация email: должен быть уникальным"""
    if User.objects.filter(email=value).exists():
        raise serializers.ValidationError(["Пользователь с таким email уже существует."])
    return value.lower()
```

**Риски:**
- Перечисление пользователей
- Утечка информации о зарегистрированных email

**Рекомендации:**
- Использовать одинаковое сообщение для существующих и несуществующих email
- Добавить задержку для выравнивания времени ответа
- Рассмотреть отправку email "если аккаунт существует, мы отправили инструкции"

**Приоритет:** Низкий  
**Статус:** Открыта

---

#### 20. Отсутствие ротации JWT токенов при смене пароля
**Описание:** При смене пароля не происходит инвалидация существующих JWT токенов, они остаются валидными до истечения срока.

**Расположение:** `users/views.py:207-222`

**Риски:**
- Использование украденных токенов после смены пароля
- Продолжение доступа со старыми токенами

**Рекомендации:**
- Добавить токены в blacklist при смене пароля
- Использовать `token_blacklist` приложения
- Рассмотреть добавление версии пароля в JWT payload

**Приоритет:** Низкий  
**Статус:** Открыта

---

#### 21. Отсутствие ограничений на длину refresh token
**Описание:** Refresh токены имеют длительный срок жизни (7 дней), но нет механизма их ротации при каждом использовании.

**Расположение:** `calorio_api/settings.py:241-250`

**Код:**
```python
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,  # ✅ Уже включено
    'BLACKLIST_AFTER_ROTATION': True,  # ✅ Уже включено
}
```

**Статус:** ✅ Ротация токенов уже настроена

**Риски:**
- Использование украденных refresh токенов

**Рекомендации:**
- Текущая настройка корректна
- Рассмотреть уменьшение времени жизни refresh токена
- Добавить мониторинг подозрительной активности

**Приоритет:** Низкий  
**Статус:** Частично исправлено

---

#### 22. Отсутствие валидации на формат даты в URL параметрах
**Описание:** В некоторых эндпоинтах дата передаётся через URL параметр, но валидация может быть недостаточной.

**Расположение:** `core/views.py` (DayDataView, DailyGoalView)

**Статус:** ✅ Валидация есть через `parse_date()`, но нужно убедиться в обработке всех edge cases

**Риски:**
- Ошибки при неверном формате
- Потенциальные проблемы с производительностью

**Рекомендации:**
- Убедиться, что все неверные форматы обрабатываются корректно
- Добавить более строгую валидацию формата даты
- Рассмотреть использование regex для проверки формата перед парсингом

**Приоритет:** Низкий  
**Статус:** Требует проверки

---

#### 23. .env файл в .gitignore
**Описание:** Проверка наличия .env в .gitignore.

**Расположение:** `.gitignore:42`

**Статус:** ✅ `.env` файл правильно добавлен в `.gitignore`

**Риски:**
- Утечка секретных ключей при коммите

**Рекомендации:**
- Текущая настройка корректна
- Убедиться, что `.env` не был случайно закоммичен ранее
- Использовать `.env.example` для документации необходимых переменных

**Приоритет:** Низкий  
**Статус:** Исправлено ✅

---

## Статистика

- **Всего уязвимостей:** 23
- **Критические:** 4
- **Высокие:** 6
- **Средние:** 6
- **Низкие:** 7
- **Исправлено:** 1

---

## Рекомендации по приоритетам

### Немедленно (до релиза):
1. Исправить SECRET_KEY (использовать переменные окружения)
2. Отключить DEBUG для production
3. Настроить ALLOWED_HOSTS
4. Реализовать проверку подписи webhook

### В ближайшее время:
5. Добавить rate limiting на регистрацию/логин
6. Защита от timing attacks
7. Настроить Security Headers
8. Настроить CORS для production

### В следующей итерации:
9. Улучшить логирование (маскировка чувствительных данных)
10. Защита от массовых операций
11. Валидация и санитизация пользовательского ввода

---

## Соответствие стандартам

### OWASP Top 10 (2021):
- ✅ **A01:2021 – Broken Access Control** - Частично (требует проверки IDOR)
- ⚠️ **A02:2021 – Cryptographic Failures** - SECRET_KEY в коде
- ⚠️ **A03:2021 – Injection** - Защищено ORM, но нужна проверка
- ⚠️ **A04:2021 – Insecure Design** - Webhook без проверки подписи
- ⚠️ **A05:2021 – Security Misconfiguration** - DEBUG=True, ALLOWED_HOSTS пустой
- ⚠️ **A06:2021 – Vulnerable Components** - Требуется проверка зависимостей
- ⚠️ **A07:2021 – Authentication Failures** - Timing attacks, отсутствие rate limiting
- ⚠️ **A08:2021 – Software and Data Integrity Failures** - Webhook без проверки
- ⚠️ **A09:2021 – Logging Failures** - Чувствительные данные в логах
- ⚠️ **A10:2021 – SSRF** - Требуется проверка внешних запросов

### ISO 27001:
- ⚠️ **A.9.2 User access management** - Требует улучшения
- ⚠️ **A.9.4 Control of access to program source code** - SECRET_KEY в коде
- ⚠️ **A.12.6 Management of technical vulnerabilities** - Множественные уязвимости
- ⚠️ **A.14.2 Security in development and support processes** - Недостаточная валидация

---

## Заключение

Проект имеет хорошую базовую структуру безопасности благодаря использованию Django и DRF, однако содержит ряд критических уязвимостей, которые **обязательно** должны быть устранены перед релизом в production. Особое внимание следует уделить:

1. Конфигурации для production (SECRET_KEY, DEBUG, ALLOWED_HOSTS)
2. Защите критичных эндпоинтов (webhook, аутентификация)
3. Настройке security headers и HTTPS
4. Защите от основных типов атак (timing attacks, брутфорс, DoS)

После устранения критических и высоких уязвимостей проект будет готов к релизу с точки зрения безопасности.

---

**Дата следующего аудита:** Рекомендуется провести повторный аудит после устранения критических уязвимостей.

